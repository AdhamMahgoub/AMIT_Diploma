#include "../../LIB/STD_TYPES.H"
#include "../../LIB/BIT_MATH.h"

#include "../../MCAL/DIO/DIO_interface.h"
#include "../../HAL/LCD/LCD_interface.h"

#include "Timer_private.h"
#include "Timer_config.h"

#include <avr/interrupt.h>		//	Built-in Interrupt Library

u32 ISR_Counter	= 0;
u32 time_counter = 0;

ISR (TIMER0_OVF_vect)				
{
	// Action when TIMER0 Overflow Occur
	// do nothing 
}

void Timer0_Counter_Init(void)
{
	// Set global interrupt enable bit
	SET_BIT(SREG,7);

	OCR0 = Duty_cycle * 256;

	/* Configure the timer modes (Normal, PWM, ...)	*/

	/*		Normal Mode 	*/
#if TIMER_MODE == NORMAL
	{
		CLR_BIT(TCCR0,WGM00);
		CLR_BIT(TCCR0,WGM01);
	}
#endif

	/*		CTC	Mode		*/
#if (TIMER_MODE == 1)
	{
		CLR_BIT(TCCR0,WGM00);
		SET_BIT(TCCR0,WGM01);
	}
#endif

	/*		Fast PWM		*/
#if (TIMER_MODE == 2)
	{
		SET_BIT(TCCR0,WGM00);
		SET_BIT(TCCR0,WGM01);
	}
#endif
	/*		Phase_Correct	*/

#if (TIMER_MODE == 3)
	{
		SET_BIT(TCCR0,WGM00);
		CLR_BIT(TCCR0,WGM01);
	}
#endif


	//configure the compare match (Non-PWM)

	//check PWM or non PWM//
	if (COMPARE_OUTPUT_MODE == -1)
	{
		// do nothing
		// this means i'm PWM modes
	}

	/*		0C0 Disconnected 			*/
	else if (COMPARE_OUTPUT_MODE == 1)
	{
		CLR_BIT(TCCR0,COM00);
		CLR_BIT(TCCR0,COM01);
	}

	/*		Toggle_OC0 			*/
	else if (COMPARE_OUTPUT_MODE == 2)
	{
		SET_BIT(TCCR0,COM00);
		CLR_BIT(TCCR0,COM01);
	}

	/*		Clear_OC0		 	*/
	else if (COMPARE_OUTPUT_MODE == 3)
	{
		CLR_BIT(TCCR0,COM00);
		SET_BIT(TCCR0,COM01);
	}

	/*		Set 0C0  			*/
	else if (COMPARE_OUTPUT_MODE == 4)
	{
		SET_BIT(TCCR0,COM00);
		SET_BIT(TCCR0,COM01);
	}


	//configure the compare match (PWM)

	//check PWM or non PWM//
	if (COMPARE_OUTPUT_MODE == -1)
	{
		// do nothing
		// this means i'm non-PWM modes
	}

	/*		0C0 Disconnected 			*/
	else if (COMPARE_OUTPUT_MODE == 1)
	{
		CLR_BIT(TCCR0,COM00);
		CLR_BIT(TCCR0,COM01);
	}

	/*		Clear_OC0		 	*/
	else if (COMPARE_OUTPUT_MODE == 2)
	{
		CLR_BIT(TCCR0,COM00);
		SET_BIT(TCCR0,COM01);
	}

	/*		Set 0C0  			*/
	else if (COMPARE_OUTPUT_MODE == 3)
	{
		SET_BIT(TCCR0,COM00);
		SET_BIT(TCCR0,COM01);
	}


	//configure the Timer Clock Select 		*/
	/*	Falling Edge			*/
	if (TIMER_CLK_SELECT == 0)
	{
		CLR_BIT(TCCR0,CS00);
		SET_BIT(TCCR0,CS01);
		SET_BIT(TCCR0,CS02);
	}

	/*	Rising Edge				*/
	else if (TIMER_CLK_SELECT == 1)
	{
		SET_BIT(TCCR0,CS00);
		SET_BIT(TCCR0,CS01);
		SET_BIT(TCCR0,CS02);
	}

	/*	No Prescalar 			*/
	else if (TIMER_CLK_SELECT == 2)
	{
		SET_BIT(TCCR0,CS00);
		CLR_BIT(TCCR0,CS01);
		CLR_BIT(TCCR0,CS02);
	}

	/* 	Prescalar 8			*/
	else if (TIMER_CLK_SELECT == 3)
	{
		CLR_BIT(TCCR0,CS00);
		SET_BIT(TCCR0,CS01);
		CLR_BIT(TCCR0,CS02);
	}

	/* 	Prescalar 64			*/
	else if (TIMER_CLK_SELECT == 4)
	{
		SET_BIT(TCCR0,CS00);
		SET_BIT(TCCR0,CS01);
		CLR_BIT(TCCR0,CS02);
	}

	/* 	Prescalar 256			*/
	else if (TIMER_CLK_SELECT == 5)
	{
		CLR_BIT(TCCR0,CS00);
		CLR_BIT(TCCR0,CS01);
		SET_BIT(TCCR0,CS02);
	}

	/* 	Prescalar 1024			*/
	else if (TIMER_CLK_SELECT == 6)
	{
		SET_BIT(TCCR0,CS00);
		CLR_BIT(TCCR0,CS01);
		SET_BIT(TCCR0,CS02);
	}

	//enable overflow interrupt
	SET_BIT(TIMSK,BIT_TOIE0);
}



